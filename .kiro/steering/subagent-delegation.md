# Sub-Agent Delegation Strategy

## Core Principle

**Параллелизация по умолчанию** — любая задача анализируется на возможность декомпозиции ПЕРЕД началом работы. Если задача разбивается на независимые части — они выполняются параллельно через субагентов.

## Decision Tree

```
Получена задача
    │
    ▼
┌─────────────────────────────────┐
│ Знаком ли я с этой частью кода? │
└─────────────────────────────────┘
    │ НЕТ                    │ ДА
    ▼                        ▼
context-gatherer      ┌──────────────────────┐
    │                 │ Можно ли разбить на  │
    ▼                 │ независимые части?   │
Получил контекст      └──────────────────────┘
    │                      │ ДА           │ НЕТ
    ▼                      ▼              ▼
Продолжить анализ    Параллельные      Выполнить
                     субагенты         самостоятельно
```

## Типы субагентов и их применение

### context-gatherer
**Когда:** Незнакомый код, баги, исследование архитектуры
**Лимит:** 1 раз на запрос, в самом начале
```
Промпт: "Найди все файлы связанные с [функциональность]. 
        Определи точки входа, зависимости, flow данных."
```

### general-task-execution (параллельные)
**Когда:** Независимые изменения в разных частях системы

## Паттерны декомпозиции

### По слоям архитектуры
```
Задача: "Добавить фичу X"

SubAgent 1 (Backend):
  - Файлы: src-tauri/src/core/*.rs
  - Задача: модели, логика, Tauri commands
  
SubAgent 2 (Frontend):  
  - Файлы: src/routes/*, src/lib/*
  - Задача: UI компоненты, stores, страницы
  
SubAgent 3 (Config):
  - Файлы: configs/*
  - Задача: конфигурации, схемы
```

### По модулям
```
Задача: "Рефакторинг системы стратегий"

SubAgent 1: strategy_engine.rs + strategy_tester.rs
SubAgent 2: nodpi_engine.rs + vless_engine.rs  
SubAgent 3: UI стратегий (strategies/+page.svelte)
```

### По типу работы
```
Задача: "Исправить баг + добавить логирование"

SubAgent 1: Исправление бага (точечное изменение)
SubAgent 2: Добавление логирования (широкое изменение)
```

## Формат промпта для субагента

Каждый субагент получает структурированный промпт:

```
## Контекст
[Что это за проект/модуль, зачем нужна задача]

## Задача
[Конкретное действие с измеримым результатом]

## Scope (файлы)
- file1.rs — что изменить
- file2.svelte — что изменить

## Ограничения
- НЕ трогать: [файлы других субагентов]
- НЕ делать: [что выходит за рамки]

## Критерии готовности
- [ ] Код компилируется
- [ ] [Специфичные проверки]
```

## Правила изоляции

### Файловая изоляция
- Каждый субагент работает со своим набором файлов
- Пересечение файлов = последовательное выполнение
- Общие типы/интерфейсы — определить заранее

### Контрактная изоляция
```
Если SubAgent 1 создаёт API, а SubAgent 2 его использует:

1. Сначала определить контракт (типы, сигнатуры)
2. Запустить параллельно с mock/stub
3. Интегрировать после завершения обоих
```

## Когда НЕ использовать субагентов

❌ Тривиальные задачи (< 2 минут, 1-2 файла)
❌ Сильно связанные изменения (один файл влияет на другой)
❌ Отладка с неизвестной причиной (сначала context-gatherer)
❌ Задачи требующие итеративного уточнения с пользователем

## Примеры из проекта Isolate

### Пример 1: Новая стратегия
```
Задача: "Добавить стратегию для Discord"

→ Параллельно:
  SubAgent 1: configs/strategies/discord.yaml + hostlists
  SubAgent 2: UI выбора стратегии (если нужны изменения)
  
→ Последовательно (зависит от конфига):
  SubAgent 3: Тестирование через strategy_tester.rs
```

### Пример 2: Баг в тестировании
```
Задача: "Тесты стратегий зависают"

→ Сначала:
  context-gatherer: strategy_tester.rs, process_runner.rs, 
                    связанные модули
                    
→ После анализа (если независимые причины):
  SubAgent 1: Таймауты в process_runner
  SubAgent 2: Graceful shutdown в strategy_tester
```

### Пример 3: UI + Backend фича
```
Задача: "Добавить статистику использования"

→ Параллельно:
  SubAgent 1 (Rust): 
    - src-tauri/src/core/telemetry.rs — сбор метрик
    - src-tauri/src/commands/ — новые commands
    
  SubAgent 2 (Svelte):
    - src/routes/stats/+page.svelte — новая страница
    - src/lib/api.ts — типы и вызовы
```

## Метрики эффективности

Хорошая декомпозиция если:
- Субагенты завершаются примерно одновременно (±30% времени)
- Нет блокировок на merge результатов
- Каждый субагент делает осмысленную часть работы

Плохая декомпозиция если:
- Один субагент ждёт другого
- Много конфликтов при интеграции
- Субагент делает слишком мало (overhead > пользы)
